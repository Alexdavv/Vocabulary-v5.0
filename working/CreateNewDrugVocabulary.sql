    /**************************************************************************
    * Copyright 2016 Observational Health Data Sciences and Informatics (OHDSI)
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * 
    * Authors: Christian Reich
    * Date: 2016
    **************************************************************************/

    -- To do: Ingredient to Brand Name (has brand name), product to Brand Name (has tradename), possible excipient, mEq to mmol, other funny units
    -- Add filter for standard_concept=null and pass through 'Concept_replaced_by' or 'Maps to' links (for Ingredients, Forms, Brand Names)
    -- Add 'Marketed Product', change from Clinical% and Branded% to Drug Product
    -- Put all "drops" to the end

    /******************************************************************************
    * This script creates a new drug vocabulary in the OMOP Standard Vocabularies *
    * The new drug vocabulary must be provided in the format described in         *
    * http://www.ohdsi.org/web/wiki/doku.php?id=documentation:international_drugs *
    * The processing is also described there. The following tables are required:  *
    * drug_concept_stage, internal_relationship_stage, relationship_to_concept,   *
    * ds_stage. Records that have no concept_code in the source should            *
    * receive autogenerated ones in the format 'OMOP' plus a running number.      *
    * The tables concept, concept_relationship, concept_ancestor and              *
    * drug_strength need to be locally availabe.                                  *
    *******************************************************************************/

    /** IMPORTANT **/
    /* Add the latest_udpate and version information to the VOCABULARY table **/
 
    create index idx_dcs_concept_code ON drug_concept_stage (concept_code);
    -- Create temporary for uniqe strength recordsdrop sequence ds_seq;
    --drop sequence ds_seq;
    create sequence ds_seq increment by 1 start with 1 nocycle cache 20 noorder;

    -- Create sequence for temporary XXX concept codes
    --drop sequence xxx_seq;
    create sequence xxx_seq increment by 1 start with 1 nocycle cache 20 noorder;

    commit;

    -- 1. Prepare drug components for new vocabularies: Create unique list and for each drug enumerate. This allows to create a single row for each drug.

    -- Create distinct version of drug_strength 
    -- Replace nulls with 0 and ' '
    --drop table unique_ds purge;
    create table unique_ds nologging as
    select ds_seq.nextval as ds_code, ds.* from (
      select distinct ingredient_concept_code, 
        nvl(amount_value, 0) as amount_value, nvl(amount_unit, ' ') as amount_unit, 
        case 
          when numerator_unit='%' then nvl(numerator_value, 0)
          when nvl(numerator_value, 0)=0 then 0 
    -- round to 3 significant number of digits
          else round(nvl(numerator_value, 0)/nvl(denominator_value, 1), 3-floor(log(10, nvl(numerator_value, 0)/nvl(denominator_value, 1)))-1)
        end as numerator_value, 
        nvl(numerator_unit, ' ') as numerator_unit, 
        nvl(denominator_unit, ' ') as denominator_unit
      from ds_stage
      where coalesce(amount_value, numerator_value, denominator_value) is not null -- needs to have at least one value 
      and coalesce(amount_unit, numerator_unit, denominator_unit) is not null -- needs to have at least one unit
    ) ds
    ;


    -- Create table with all drug concept codes linked to the above unique components 
    --drop table ds cascade constraints purge;
    create table ds nologging as
    select dss.drug_concept_code as concept_code, uds.ds_code
    from ds_stage dss
    join unique_ds uds on uds.ingredient_concept_code=dss.ingredient_concept_code
      and uds.amount_value=nvl(dss.amount_value, 0) and uds.amount_unit=nvl(dss.amount_unit, ' ')
      and uds.numerator_value=
        case 
          when dss.numerator_unit='%' then nvl(dss.numerator_value, 0) 
          when nvl(dss.numerator_value, 0)=0 then 0 
    -- compare to rounded to 3 significant number of digits
          else round(nvl(dss.numerator_value, 0)/nvl(dss.denominator_value, 1), 3-floor(log(10, nvl(dss.numerator_value, 0)/nvl(dss.denominator_value, 1)))-1)
        end 
      and uds.numerator_unit=nvl(dss.numerator_unit, ' ')
      and uds.denominator_unit=nvl(dss.denominator_unit, ' ')
    ;
    create index idx_ds on ds (ds_code);

    -- Create table with the combination of components for each drug concept delimited by '-'
    --drop table ds_combo purge;
    create table ds_combo as
    select distinct concept_code, listagg(ds_code, '-') within group (order by ds_code) as combo_code
    from ds
    group by concept_code
    ;

    -- Create table with all drug concept codes linked to the codes of the ingredients (rather than full dose components)
    --drop table ing purge;
    create table ing nologging as
    select c.concept_code, i.concept_code as ing_code
    from drug_concept_stage c
    join internal_relationship_stage r on r.concept_code_1=c.concept_code
    join drug_concept_stage i on i.concept_code=r.concept_code_2 and i.concept_class_id='Ingredient'
    where (c.concept_class_id like '%Drug%') and c.domain_id='Drug'; -- Change to Marketed Product and Drug Product

    -- Create table with the combination of ingredients for each drug concept delimited by '-'
    --drop table ing_combo purge;
    create table ing_combo nologging as
    select distinct concept_code, listagg(ing_code, '-') within group (order by ing_code) as combo_code
    from ing
    group by concept_code
    ;

    -- Create table to convert from ingredients to components
    --drop table ing_to_ds purge;
    create table ing_to_ds nologging as
    select distinct i.combo_code as ing_combo_code, d.combo_code as ds_combo_code from ing_combo i join ds_combo d on d.concept_code=i.concept_code;

    -- Manufacturers (suppliers)
    create table manufact nologging as
    select irs.CONCEPT_CODE_1 as concept_code, irs.CONCEPT_CODE_2 as mf_code from drug_concept_stage dcs
    JOIN internal_relationship_stage irs on irs.concept_code_2=dcs.concept_code
    WHERE dcs.CONCEPT_CLASS_ID = 'Supplier';

    -- Create table with Quantity Factor information for each drug (if exists)
    --drop table quant purge;
    create table quant nologging as
    select distinct drug_concept_code as concept_code, denominator_value
    from ds_stage
    where denominator_value is not null and denominator_value!=0
    ;

    -- Create table with Brand Name information for each drug (if exists)
    --drop table bn purge;
    create table bn nologging as
    select distinct ir.concept_code_1 as concept_code, b.concept_code as brand_code -- distinct only because source contains duplicated maps
    from internal_relationship_stage ir
    join drug_concept_stage b on b.concept_code=ir.concept_code_2 and b.concept_class_id='Brand Name' and b.domain_id='Drug' -- Brand Name of a drug
    ;

    -- Create table with Dose Form information for each drug (if exists)
    --drop table df purge;
    create table df nologging as
    select distinct ir.concept_code_1 as concept_code, f.concept_code as dose_form_code -- distinct only because source contains duplicated maps
    from internal_relationship_stage ir
    join drug_concept_stage f on f.concept_code=ir.concept_code_2 and f.concept_class_id='Dose Form' and f.domain_id='Drug' -- Dose Form of a drug
    ;

    -- Create table with Box Size information for each drug (if exists)
    --drop table bs purge;
    create table bs nologging as
    select distinct drug_concept_code as concept_code, box_size 
    from ds_stage where box_size is not null;


    -- 2. Create the list of all all existing product. 

    -- Duplication rule 1: More than one definition per concept_code is illegal
    -- Duplication rule 2: More than one concept_code per definition needs deprecation of the duplicates

    -- Collect all input drugs and create master matrix
    --drop table existing_concept_stage purge;
    create table existing_concept_stage nologging as
    -- Marketed Product
      select distinct 
        i.concept_code, nvl(quant.denominator_value,0) as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, nvl(df.dose_form_code,' ') as dose_form_code,
         nvl(bn.brand_code,' ') as brand_code, nvl(bs.box_size,0) as box_size, mf.mf_code as mf_code,
        'Marketed Product' as concept_class_id
      from ing_combo i
      join ds_combo d on d.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code 
      join manufact mf on mf.concept_code=i.concept_code 
      left join quant on quant.concept_code=i.concept_code
      left join bn on bn.concept_code=i.concept_code
      left join bs on bs.concept_code=i.concept_code
    union
    -- Quant Branded Box
      select distinct 
        i.concept_code, quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, bs.box_size, ' ' as mf_code,
        'Quant Branded Box' as concept_class_id
      from ing_combo i
      join ds_combo d on d.concept_code=i.concept_code
      join quant on quant.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
      join bn on bn.concept_code=i.concept_code
      join bs on bs.concept_code=i.concept_code
      left join manufact mf on mf.concept_code=i.concept_code 
      where mf.mf_code is null
    union
    -- Quant Clinical Box
      select distinct 
        i.concept_code, quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, bs.box_size, ' ' as mf_code,
        'Quant Clinical Box' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      join quant on quant.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
      left join bn on bn.concept_code=i.concept_code
      join bs on bs.concept_code=i.concept_code
      left join manufact mf on mf.concept_code=i.concept_code 
      where bn.concept_code is null and mf.mf_code is null
    union
    -- Branded Drug Box
      select distinct 
        i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, bs.box_size, ' ' as mf_code,
        'Branded Drug Box' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      left join quant on quant.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
      join bn on bn.concept_code=i.concept_code
      join bs on bs.concept_code=i.concept_code 
      left join manufact mf on mf.concept_code=i.concept_code 
      where quant.concept_code is null and mf.mf_code is null
    union
    -- Clinical Drug Box
      select distinct 
        i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, bs.box_size, ' ' as mf_code,
        'Clinical Drug Box' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      left join quant on quant.concept_code=d.concept_code
      join df on df.concept_code=d.concept_code
      left join bn on bn.concept_code=d.concept_code
      join bs on bs.concept_code=d.concept_code 
      left join manufact mf on mf.concept_code=i.concept_code 
      where quant.concept_code is null and bn.concept_code is null and mf.mf_code is null
    union
    -- Quant Branded Drug
      select distinct 
        i.concept_code, quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, 0 as box_size, ' ' as mf_code,
        'Quant Branded Drug' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      join quant on quant.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
      join bn on bn.concept_code=i.concept_code
      left join bs on bs.concept_code=i.concept_code 
      left join manufact mf on mf.concept_code=i.concept_code 
      where bs.concept_code is null and mf.mf_code is null
    union
    -- Quant Clinical Drug
      select distinct 
        i.concept_code, quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, 0 as box_size, ' ' as mf_code,
        'Quant Clinical Drug' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      join quant on quant.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
      left join bn on bn.concept_code=i.concept_code
      left join bs on bs.concept_code=i.concept_code 
      left join manufact mf on mf.concept_code=i.concept_code
      where bn.concept_code is null and bs.concept_code is null and mf.mf_code is null
    union
    -- Branded Drug
      select distinct 
        i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, 0 as box_size, ' ' as mf_code,
        'Branded Drug' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      left join quant on quant.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
      join bn on bn.concept_code=i.concept_code
      left join bs on bs.concept_code=i.concept_code 
      left join manufact mf on mf.concept_code=i.concept_code
      where quant.concept_code is null and bs.concept_code is null AND mf.mf_code is null
    union
    -- Clinical Drug
      select distinct 
        i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, 0 as box_size, ' ' as mf_code,
        'Clinical Drug' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      left join quant on quant.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
      left join bn on bn.concept_code=i.concept_code
      left join bs on bs.concept_code=i.concept_code 
      left join manufact mf on mf.concept_code=i.concept_code
      where quant.concept_code is null and bn.concept_code is null and bs.concept_code is null and mf.mf_code is null
    union
    -- Branded Drug Form
      select distinct 
        i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, ' ' as d_combo_code, df.dose_form_code, bn.brand_code, 0 as box_size, ' ' as mf_code,
        'Branded Drug Form' as concept_class_id
      from ing_combo i 
      left join ds_combo d on d.concept_code=i.concept_code
      left join quant on quant.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
      join bn on bn.concept_code=i.concept_code
      left join bs on bs.concept_code=i.concept_code 
      where quant.concept_code is null and d.concept_code is null and bs.concept_code is null
    union
    -- Clinical Drug Form
      select distinct 
        i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, ' ' as d_combo_code, df.dose_form_code, ' ' as brand_code, 0 as box_size, ' ' as mf_code,
        'Clinical Drug Form' as concept_class_id
      from ing_combo i 
      left join ds_combo d on d.concept_code=i.concept_code
      left join quant on quant.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
      left join bn on bn.concept_code=i.concept_code
      left join bs on bs.concept_code=i.concept_code 
      where quant.concept_code is null and d.concept_code is null and bn.concept_code is null and bs.concept_code is null
    union
    -- Branded Drug Component
      select distinct 
        i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, ' ' as dose_form_code, bn.brand_code, 0 as box_size, ' ' as mf_code,
        'Branded Drug Comp' as concept_class_id
      from ing_combo i
      join ds_combo d on d.concept_code=i.concept_code
      left join quant on quant.concept_code=i.concept_code
      left join df on df.concept_code=i.concept_code
      join bn on bn.concept_code=i.concept_code
      left join bs on bs.concept_code=i.concept_code 
      where quant.concept_code is null and df.concept_code is null and bs.concept_code is null
    union
    -- Clinical Drug Component 
      select distinct 
        i.concept_code, 0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, 0 as box_size, ' ' as mf_code,
        'Clinical Drug Comp' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      left join quant on quant.concept_code=i.concept_code
      left join df on df.concept_code=i.concept_code
      left join bn on bn.concept_code=i.concept_code
      left join bs on bs.concept_code=i.concept_code 
      where quant.concept_code is null and df.concept_code is null and bn.concept_code is null and bs.concept_code is null
    ;

    -- 3. Write all concept classes, whether existing or not from all possible combinations

    --drop table complete_concept_stage cascade constraints purge;
    create table complete_concept_stage nologging as
    select distinct * from (
    select * from existing_concept_stage
    union
    select distinct nvl(first_value(e.concept_code) over (partition by e.denominator_value, e.i_combo_code, e.d_combo_code, e.dose_form_code, e.brand_code, e.box_size, e.mf_code order by concept_code desc), 0) as concept_code,
      c.*
    from (
    -- Marketed Product
      select distinct 
        nvl(quant.denominator_value,0) as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code,  nvl(df.dose_form_code,' ') as dose_form_code, nvl(bn.brand_code,' ') as brand_code, nvl(bs.box_size,0) as box_size, mf.mf_code,
        'Marketed Product' as concept_class_id
      from ing_combo i
      join ds_combo d on d.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code 
      join manufact mf on mf.concept_code=i.concept_code 
      left join quant on quant.concept_code=i.concept_code
      left join bn on bn.concept_code=i.concept_code
      left join bs on bs.concept_code=i.concept_code
    union  
    -- Quant Branded Box
      select distinct 
        quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, bs.box_size, ' ' as mf_code,
        'Quant Branded Box' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      join quant on quant.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
      join bn on bn.concept_code=i.concept_code
      join bs on bs.concept_code=i.concept_code 
    union
    -- Quant Clinical Box
      select distinct 
        quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, bs.box_size, ' ' as mf_code,
        'Quant Clinical Box' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      join quant on quant.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
      join bs on bs.concept_code=i.concept_code 
    union
    -- Branded Drug Box
      select distinct 
        0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, bs.box_size, ' ' as mf_code,
        'Branded Drug Box' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
      join bn on bn.concept_code=i.concept_code
      join bs on bs.concept_code=i.concept_code 
    union
    -- Clinical Drug Box
      select distinct 
        0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, bs.box_size, ' ' as mf_code,
        'Clinical Drug Box' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      join df on df.concept_code=d.concept_code
      join bs on bs.concept_code=d.concept_code 
    union
    -- Quant Branded Drug
      select distinct 
        quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, 0 as box_size, ' ' as mf_code,
        'Quant Branded Drug' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      join quant on quant.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
      join bn on bn.concept_code=i.concept_code
    union
    -- Quant Clinical Drug
      select distinct 
        quant.denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, 0 as box_size, ' ' as mf_code,
        'Quant Clinical Drug' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      join quant on quant.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
    union
    -- Branded Drug
      select distinct 
        0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, bn.brand_code, 0 as box_size, ' ' as mf_code,
        'Branded Drug' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
      join bn on bn.concept_code=i.concept_code
    union
    -- Clinical Drug
      select distinct 
        0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, df.dose_form_code, ' ' as brand_code, 0 as box_size, ' ' as mf_code,
        'Clinical Drug' as concept_class_id
      from ing_combo i 
      join ds_combo d on d.concept_code=i.concept_code
      join df on df.concept_code=i.concept_code
    union
    -- Branded Drug Form
      select distinct 
        0 as denominator_value, i.combo_code as i_combo_code, ' ' as d_combo_code, df.dose_form_code, bn.brand_code, 0 as box_size, ' ' as mf_code,
        'Branded Drug Form' as concept_class_id
      from ing_combo i 
      join df on df.concept_code=i.concept_code
      join bn on bn.concept_code=i.concept_code
    union
    -- Clinical Drug Form
      select distinct 
        0 as denominator_value, i.combo_code as i_combo_code, ' ' as d_combo_code, df.dose_form_code, ' ' as brand_code, 0 as box_size, ' ' as mf_code,
        'Clinical Drug Form' as concept_class_id
      from ing_combo i 
      join df on df.concept_code=i.concept_code
    union
    -- Branded Drug Component
      select distinct 
        0 as denominator_value, i.combo_code as i_combo_code, d.combo_code as d_combo_code, ' ' as dose_form_code, bn.brand_code, 0 as box_size, ' ' as mf_code,
        'Branded Drug Comp' as concept_class_id
      from ing_combo i
      join ds_combo d on d.concept_code=i.concept_code
      join bn on bn.concept_code=i.concept_code
    union
    -- Clinical Drug Component - they are unique per ingredients
      select distinct 
        0 as denominator_value, i.ing_code as i_combo_code, cast(d.ds_code as varchar(20)) as d_combo_code, ' ' as dose_form_code, ' ' as brand_code, 0 as box_size, ' ' as mf_code,
        'Clinical Drug Comp' as concept_class_id
      from ing i 
      join unique_ds d on i.ing_code=d.ingredient_concept_code 
    ) c
    left join existing_concept_stage e on c.denominator_value=e.denominator_value and c.i_combo_code=e.i_combo_code and c.d_combo_code=e.d_combo_code 
      and c.dose_form_code=e.dose_form_code and c.brand_code=e.brand_code and c.box_size=e.box_size AND c.mf_code=e.mf_code
    )
    ;

    -- Add Packs
    insert /*+ APPEND */ into complete_concept_stage
    select 
      dcs.concept_code,
      0 as denominator_value,
      ' ' as i_combo_code,
      ' ' as d_combo_code,
      ' ' as dose_form_code,
      ' ' as brand_code,
      0 as box_size,
      dcsm.concept_code as mf_code,
      'Marketed Product' as concept_class_id
    from drug_concept_stage dcs 
    join internal_relationship_stage irs ON irs.concept_code_1=dcs.concept_code
    join drug_concept_stage dcsm ON irs.concept_code_2=dcsm.concept_code AND dcsm.concept_class_id = 'Supplier'
    where dcs.concept_class_id like '%Pack' and dcs.domain_id='Drug'
    ;
    commit;

    --drop table nmf_packs;
    create table nmf_packs (
      concept_code varchar2(50),
      nmf_code varchar2(50)
    );  

    insert /*+ APPEND */ into nmf_packs
    select 
     dcs.concept_code,
     'XXX'||xxx_seq.nextval as nmf_code
    from drug_concept_stage dcs 
    join internal_relationship_stage irs ON irs.concept_code_1=dcs.concept_code
    join drug_concept_stage dcsm ON irs.concept_code_2=dcsm.concept_code AND dcsm.concept_class_id = 'Supplier'
    where dcs.concept_class_id like '%Pack' and dcs.domain_id='Drug';

    commit;

    insert /*+ APPEND */ into complete_concept_stage
    select 
      nmf_code as concept_code,
      0 as denominator_value,
      ' ' as i_combo_code,
      ' ' as d_combo_code,
      ' ' as dose_form_code,
      ' ' as brand_code,
      0 as box_size,
      ' ' as mf_code,
      concept_class_id
    from drug_concept_stage dcs JOIN nmf_packs nmf ON nmf.concept_code=dcs.concept_code
    where concept_class_id like '%Pack' and domain_id='Drug'
    ;
    commit;

    -- Replace remaining concept_code=0 with OMOP123 style temporary concept codes. 
    update complete_concept_stage ccs 
      set concept_code='XXX'||xxx_seq.nextval -- make sure xxx_seq is defined.
    where ccs.concept_code='0';

    create index idx_ccs_concept_code ON complete_concept_stage (concept_code);
    create index idx_ccs_d_combo_code ON complete_concept_stage (d_combo_code);

    -- 4. Auto-generate all names unless a name is provided

    -- create table with all names, later to be joined with complete_concept_stage
    --drop table complete_name;
    create table complete_name (
      concept_code varchar2(50),
      concept_name varchar2(255)
    );  

    -- create names for everything but 'Clinical Drug Form', 'Branded Drug Form' (no drug_strength) and 'Clinical Drug Comp' (single ingredient)
    insert /*+ APPEND */ into complete_name
    with spelled_out as (
      select 
        c.concept_code,
        case when c.denominator_value=0 then '' else c.denominator_value||' '||d.denominator_unit||' ' end as quant,
        comp.comp_name,
        sum(comp.comp_len) over (partition by c.concept_code order by comp.comp_name rows between unbounded preceding and current row) as agg_len,
        case when df.concept_name is null then '' else ' '||df.concept_name end as df_name,
        case when bn.concept_name is null then '' else ' ['||bn.concept_name||']' end as bn_name,
        case when c.box_size=0 then '' else ' Box of '||c.box_size end as box,
        case when mf.concept_name is null then '' else ' by '||mf.concept_name end as mf_name
      from complete_concept_stage c
      -- get component names and lengths
      join (
        select combo_code, comp_name, length(comp_name)+3 as comp_len -- length plus 3 characters for ' / '
        from (
          select distinct dsc.combo_code, 
          i.concept_name||
            case 
              when u.amount_value=0 and u.numerator_unit='%' then ' '||u.numerator_value||'%' 
              when u.amount_value=0 and u.numerator_value!=0 then ' '||u.numerator_value||' '||u.numerator_unit||'/'||u.denominator_unit 
              when u.amount_value!=0 then ' '||u.amount_value||' '||u.amount_unit 
              else ''
            end as comp_name
          from ds_combo dsc join ds on ds.concept_code=dsc.concept_code join unique_ds u on u.ds_code=ds.ds_code
          join drug_concept_stage i on i.concept_code=u.ingredient_concept_code
        )
      ) comp on comp.combo_code=c.d_combo_code
      -- get denominator_unit from unique_ds
      left join (
        select distinct dsc.combo_code, u.denominator_unit
        from ds_combo dsc join ds on ds.concept_code=dsc.concept_code join unique_ds u on u.ds_code=ds.ds_code
      ) d on c.d_combo_code=d.combo_code
      -- get dose form
      left join drug_concept_stage df on df.concept_code=c.dose_form_code
      -- get brand name
      left join drug_concept_stage bn on bn.concept_code=c.brand_code
      left join drug_concept_stage mf on mf.concept_code=c.mf_code
      where c.concept_class_id not in ('Clinical Drug Form', 'Branded Drug Form', 'Clinical Drug Comp')
    )
    select 
      concept_code,
    -- count the cumulative length of the components. The tildas are to make sure the three dots are put at the end of the list
      replace(quant||listagg(comp_name, ' / ') within group (order by comp_name)||df_name||bn_name||box||mf_name, '~~~', '...') as concept_name
    from (
    -- keep only components where concatenation will leave enough space for the quant, dose form, brand name and box size
      select * from spelled_out s
      where s.agg_len<=255-(nvl(length(s.quant), 0)+nvl(length(s.df_name), 0)+nvl(length(s.bn_name), 0)+nvl(length(s.box), 0)+nvl(length(s.mf_name), 0)+3)
    -- Add three dots if ingredients are to be cut
    union
      select 
        concept_code,
        quant,
        '~~~' as comp_name, -- last ASCII character to make sure they get sorted towards the end.
        1 as agg_len,
        df_name,
        bn_name,
        box,
        mf_name
      from spelled_out s
      where s.agg_len>255-(nvl(length(s.quant), 0)+nvl(length(s.df_name), 0)+nvl(length(s.bn_name), 0)+nvl(length(s.box), 0)+nvl(length(s.mf_name), 0)+6)
      group by quant, concept_code, df_name, bn_name, box, mf_name 
    )
    group by quant, concept_code, df_name, bn_name, box, mf_name 
    ;
    commit;

    -- Add names for Clin Drug Comps (don't have combo ingredients)
    insert /*+ APPEND */ into complete_name
    select 
      c.concept_code,
      comp.comp_name
    from complete_concept_stage c
    -- get component name, length not needed
    join (
      select combo_code, comp_name -- don't need length because only one ingredient in Clinial Drug Comps
      from (
        select distinct 'X'|| ds.ds_code as combo_code, 
        i.concept_name||
          case 
            when u.amount_value=0 and u.numerator_unit='%' then ' '||u.numerator_value||'%' 
            when u.amount_value=0 and u.numerator_value!=0 then ' '||u.numerator_value||' '||u.numerator_unit||'/'||u.denominator_unit 
            when u.amount_value!=0 then ' '||u.amount_value||' '||u.amount_unit 
            else ''
          end as comp_name
        from ds_combo dsc join ds on ds.concept_code=dsc.concept_code join unique_ds u on u.ds_code=ds.ds_code
        join drug_concept_stage i on i.concept_code=u.ingredient_concept_code
      )
    ) comp on comp.combo_code='X'|| c.d_combo_code
    where c.concept_class_id = 'Clinical Drug Comp'
    ;
    commit;

    -- Drug Forms - which have no strength information
    insert /*+ APPEND */ into complete_name
    with spelled_out as (
      select 
        c.concept_code,
        comp.ing_name,
    -- count the cumulative length of the ingredients
        sum(comp.comp_len) over (partition by c.concept_code order by comp.ing_name rows between unbounded preceding and current row) as agg_len,
        ' '||df.concept_name as df_name,
        case when bn.concept_name is null then '' else ' ['||bn.concept_name||']' end as bn_name
      from complete_concept_stage c
      -- get ingredient names and lengths
      join (
        select combo_code, ing_name, length(ing_name)+3 as comp_len -- length plus 3 characters for ' / '
        from (
          select distinct ic.combo_code, 
          i.concept_name as ing_name
          from ing_combo ic join ing on ic.concept_code=ing.concept_code 
          join drug_concept_stage i on i.concept_code=ing.ing_code
        )
      ) comp on comp.combo_code=c.i_combo_code
      -- get dose form
      left join drug_concept_stage df on df.concept_code=c.dose_form_code
      -- get brand name
      left join drug_concept_stage bn on bn.concept_code=c.brand_code
      where c.concept_class_id in ('Clinical Drug Form', 'Branded Drug Form')
    )
    select 
      concept_code,
      replace(listagg(ing_name, ' / ') within group (order by ing_name)||df_name||bn_name, '~~~', '...') as concept_name
    from (
    -- keep only components where concatenation will leave enough space for the quant, dose form, brand name and box size
      select * from spelled_out s
      where s.agg_len<=255-(nvl(length(s.df_name), 0)+nvl(length(s.bn_name), 0)+3)
    -- Add three dots if ingredients are to be cut
    union
      select 
        concept_code,
        '~~~' as ing_name, -- last ASCII character
        1 as agg_len,
        df_name,
        bn_name
      from spelled_out s
      where s.agg_len>255-(nvl(length(s.df_name), 0)+nvl(length(s.bn_name), 0)+6)
      group by concept_code, df_name, bn_name
    )
    group by concept_code, df_name, bn_name
    ;
    commit;

    -- Packs
    insert /*+ APPEND */ into complete_name
    -- Get the component parts
    with c as (
      select 
        pc.pack_concept_code as concept_code,
        case when pc.amount is null then '' else pc.amount||' ' end||'('||cn.concept_name as content_name,
        case when pc.amount is null then 0 else length(pc.amount)+1 end as a_len, -- length of the amount
        length(concept_name) as n_len -- length of the concept_name
      from pack_content pc
      join existing_concept_stage e on e.concept_code=pc.drug_concept_code
      join complete_concept_stage c on c.denominator_value=e.denominator_value and c.i_combo_code=e.i_combo_code and c.d_combo_code=e.d_combo_code 
        and c.dose_form_code=e.dose_form_code and c.brand_code=e.brand_code and c.box_size=e.box_size and c.mf_code=' '
      join complete_name cn on cn.concept_code=c.concept_code
      union
      select 
        nmfp.NMF_CODE as concept_code,
        case when pc.amount is null then '' else pc.amount||' ' end||'('||cn.concept_name as content_name,
        case when pc.amount is null then 0 else length(pc.amount)+1 end as a_len, -- length of the amount
        length(concept_name) as n_len -- length of the concept_name
      from nmf_packs nmfp JOIN pack_content pc ON pc.PACK_CONCEPT_CODE=nmfp.CONCEPT_CODE
      join existing_concept_stage e on e.concept_code=pc.drug_concept_code
      join complete_concept_stage c on c.denominator_value=e.denominator_value and c.i_combo_code=e.i_combo_code and c.d_combo_code=e.d_combo_code 
        and c.dose_form_code=e.dose_form_code and c.brand_code=e.brand_code and c.box_size=e.box_size and c.mf_code=' '
      join complete_name cn on cn.concept_code=c.concept_code
    ),
    -- Get the common part
    p as (
      select 
        ccs.concept_code, 
        bn.concept_name, 
        case when mf.concept_name is null then '' else ' by '||mf.concept_name end as mf_name,
        length(bn.concept_name) + nvl(length(mf.concept_name)+4,0) as len -- length of the Brand Name of the Pack plus extra characters making up the name minus the ' / ' at the last component
      from complete_concept_stage ccs
      JOIN drug_concept_stage dcs ON dcs.concept_code=ccs.concept_code OR 'NMTF'||dcs.concept_code=ccs.concept_code
      JOIN (select dcsbn.*, irs.concept_code_1 from internal_relationship_stage irs 
        JOIN drug_concept_stage dcsbn ON dcsbn.concept_code=irs.concept_code_2 AND dcsbn.concept_class_id = 'Brand Name') bn ON bn.concept_code_1 = ccs.concept_code
      LEFT JOIN (select dcsm.*, irs.concept_code_1 from internal_relationship_stage irs 
        JOIN drug_concept_stage dcsm ON dcsm.concept_code=irs.concept_code_2 AND dcsm.concept_class_id = 'Supplier') mf ON mf.concept_code_1 = ccs.concept_code
      where dcs.concept_class_id like '%Pack%' and dcs.domain_id='Drug'
      union
      select 
        ccs.concept_code, 
        bn.concept_name, 
        '' as mf_name,
        length(bn.concept_name) as len -- length of the Brand Name of the Pack plus extra characters making up the name minus the ' / ' at the last component
      from complete_concept_stage ccs
      JOIN nmf_packs nmfp ON nmfp.nmf_code=ccs.concept_code
      JOIN (select dcsbn.*, irs.concept_code_1 from internal_relationship_stage irs 
        JOIN drug_concept_stage dcsbn ON dcsbn.concept_code=irs.concept_code_2 AND dcsbn.concept_class_id = 'Brand Name') bn ON bn.concept_code_1 = nmfp.concept_code
    ),
    -- Calculate total length of everything if space weren't the issue, and then calculate the factor that each concept_name needs to be shortened by
    l as (
      select concept_code, 
        (243-all_a_len-p.len)/all_n_len as factor -- 255-12 for common pack text (curly brackets, spaces)
      from (
        select distinct
          concept_code,
          sum(n_len) over (partition by concept_code) as all_n_len, -- 7: slashes, parentheses and spaces, minus the trailing ' / '
          sum(a_len+5) over (partition by concept_code) -3 as all_a_len -- 7: slashes, parentheses and spaces, minus the trailing ' / '
        from c
      ) 
      join p using(concept_code)
    ),
    -- Cut the individual components by the factor and add ...
    c_p as (
      select 
        concept_code,
        case when l.factor<1 then substr(c.content_name, 1, c.n_len*l.factor-3)||'...' else c.content_name end as concept_name
      from l join c using(concept_code)
    -- where concept_code='2254581'
    )
    select 
      concept_code,
      '{'||listagg(c_p.concept_name, ') / ') within group (order by c_p.concept_name) ||') } Pack ['||p.concept_name||']' || p.mf_name as concept_name
    from c_p -- components, possibly trimmed
    join p using(concept_code) -- common part
    group by concept_code, p.concept_name, p.mf_name -- aggregate within concept_code
    ;
    commit;

    -- 4. Compare new drug vocabulary q to existing one r

    -- Create lookup tables for existing vocab r (RxNorm and new ones)
    -- Create table containing ingredients for each drug
    --drop table r_drug_ing purge;
    create table r_drug_ing nologging as
      select de.concept_id as drug_id, an.concept_id as ing_id, de.concept_class_id
      from concept_ancestor a 
      join concept an on a.ancestor_concept_id=an.concept_id and an.vocabulary_id in ('RxNorm', 'RxNorm Extension') and an.concept_class_id='Ingredient' 
      join concept de on de.concept_id=a.descendant_concept_id and de.vocabulary_id in ('RxNorm', 'RxNorm Extension') and de.concept_class_id!='Ingredient' 
    ;
    -- Remove unparsable Albumin products that have no drug_strength entry: Albumin Human, USP 1 NS
    delete from r_drug_ing where drug_id in (19094500, 19080557);
    commit;

    -- Count number of ingredients for each drug
    --drop table r_ing_count purge;
    create table r_ing_count nologging as
      select drug_id as did, count(*) as cnt from r_drug_ing group by drug_id
    ;
    commit;

    -- Create lookup table for query vocab q (new vocab)
    --drop table q_drug_ing purge;
    create table q_drug_ing as
    select distinct i.concept_code as drug_code, nvl(c.concept_id, 0) as ing_id, i.ing_code, i.concept_class_id -- if ingredient is not mapped use 0 to get the right count
    from (
      select distinct css.concept_code, i.ing_code, css.concept_class_id from complete_concept_stage css
      join ing_combo ic on ic.combo_code=css.i_combo_code
      join ing i on i.concept_code=ic.concept_code
    ) i
    left join relationship_to_concept r on r.concept_code_1=i.ing_code
    left join concept c on c.concept_id=r.concept_id_2 -- link standard ingredients to existing ones
    ;
    -- Count ingredients per drug
    --drop table q_ing_count purge;
    create table q_ing_count nologging as
      select drug_code as dcode, count(*) as cnt from q_drug_ing group by drug_code
    ;
    commit;
    --select * from r_drug_ing;
    -- Create table that lists for each ingredient all drugs containing it from q and r
    --drop table match purge;
    create table match nologging as
      select q.ing_id as r_iid, q.ing_code as q_icode, q.drug_code as q_dcode, r.drug_id as r_did
      from q_drug_ing q join r_drug_ing r on q.ing_id=r.ing_id and q.concept_class_id=r.concept_class_id-- match query and result drug on common ingredient
    ;
    create index x_match on match(q_dcode, r_did);
    commit;

    -- Create table with all drugs in q and r and the number of ingredients they share
    --drop table shared_ing purge;
    create table shared_ing nologging as
    select r_did, q_dcode, count(*) as cnt from match group by r_did, q_dcode
    ;
    commit;

    -- Create matching table for all drugs (q and r) that share ingredients and their total amount
    --drop table m purge;
    create table m nologging as 
    select distinct m.*, rc.cnt as rc_cnt, r.precedence as i_prec
    from match m
    join q_ing_count qc on qc.dcode=m.q_dcode -- count number of ingredients on query (left side) drug
    join r_ing_count rc on rc.did=m.r_did and qc.cnt=rc.cnt -- count number of ingredients on result (right side) drug. 
    join shared_ing on shared_ing.r_did=m.r_did and shared_ing.q_dcode=m.q_dcode and shared_ing.cnt=qc.cnt -- and make sure the number of shared ingredients is the same as the total number of ingredients for both q and r
    join relationship_to_concept r on r.concept_code_1=m.q_icode and r.concept_id_2=m.r_iid
    ;
    commit;

    -- Create table with Dose Forms for q
    --drop table q_df purge;
    create table q_df nologging as 
    select css.concept_code as concept_code_1, 
      case when css.dose_form_code=' ' then 0 -- No Dose Form
        when m.concept_id_2 is null then 1 -- Dose Form, but not mapped
        else m.concept_id_2 
      end as concept_id_2, 
      nvl(m.precedence, 1) as precedence
    from complete_concept_stage css
    left join relationship_to_concept m on m.concept_code_1=css.dose_form_code
    ;
    commit;

    -- Create table with Dose Forms for r
    --drop table r_df purge;
    create table r_df nologging as 
    select r.concept_id_1, r.concept_id_2 from concept_relationship r
    join concept on concept_id=r.concept_id_2 and concept_class_id ='Dose Form' -- Dose Form of r
    where r.invalid_reason is null and r.relationship_id='RxNorm has dose form'
    ;
    commit;

    -- Create table wiht Brand Names for q
    --drop table q_bn purge;
    create table q_bn nologging as
    select css.concept_code as concept_code_1, 
      case when css.brand_code=' ' then 0 -- No Brand Name
        when m.concept_id_2 is null then 1 -- Brand Name, but not mapped
        else m.concept_id_2 
      end as concept_id_2, 
      nvl(m.precedence, 1) as precedence
    from complete_concept_stage css
    left join relationship_to_concept m on m.concept_code_1=css.brand_code 
    ;
    commit;

    -- Create table with Brand Names for r
    --drop table r_bn purge;
    create table r_bn nologging as
    select r.concept_id_1, r.concept_id_2 
    from concept_relationship r
    join concept on concept_id=r.concept_id_2 and concept_class_id ='Brand Name'
    where r.invalid_reason is null 
    ;
    commit;

    -- Create table that matches drugs q to r, based on Ingredient, Dose Form and Brand Name (if exist). Dose, box size or quantity are not yet compared
    --drop table q_to_r_anydose purge;
    create table q_to_r_anydose nologging as
    -- create table with all query drug codes q_dcode mapped to standard drug concept ids r_did, irrespective of the correct dose
    select distinct
      m.q_dcode, m.q_icode, m.r_did, m.r_iid, m.i_prec,
      q_df.precedence as df_prec, 
      q_bn.precedence as bn_prec,
      m.rc_cnt -- the number of ingredients in the r. 
    from m
    -- get the Dose Forms for each q and r
    join q_df on q_df.concept_code_1=m.q_dcode 
    left join r_df on r_df.concept_id_1=m.r_did -- RxNorm does not have Dose Forms for non-formed concept classes
    -- get Brand Names for q and r
    join q_bn on q_bn.concept_code_1=m.q_dcode
    left join r_bn on r_bn.concept_id_1=m.r_did -- RxNorm does not have Brand Names for non-Branded drugs or concept_classes
    -- get the quantity factor for q and r
    join (
      select distinct concept_code as drug_concept_code, denominator_value as q_value from complete_concept_stage
    ) q_quant on q_quant.drug_concept_code=m.q_dcode
    left join ( -- RxNorm might not have drug_strength for all concept_class_id
      select distinct drug_concept_id, nvl(denominator_value, 0) as q_value from drug_strength dss
    ) r_quant on r_quant.drug_concept_id=m.r_did
    -- check for matching 
    where q_df.concept_id_2=nvl(r_df.concept_id_2, 0) -- if no Dose Form match 0s
    and q_bn.concept_id_2=nvl(r_bn.concept_id_2, 0) -- if no Brand Name match 0s
    and q_quant.q_value=nvl(r_quant.q_value, 0) -- if no Quantity factors  match 0s
    ;
    commit;

    -- Add matching of dose and its units
    --drop table q_to_r_wdose purge;
    create table q_to_r_wdose nologging as
    -- q component with drug_strength in RxNorm speak (ids instead of codes) (check out '3507130' for problems with 2 precedences in liquids)
    with q as (
      select q_ds.drug_concept_code, q_ds.ingredient_concept_code, 
        q_ds.amount_value*nvl(q_ds_a.conversion_factor, 0) as amount_value, 
        q_ds_a.concept_id_2 as amount_unit_concept_id, 
        q_ds.numerator_value*nvl(q_ds_n.conversion_factor, 0) as numerator_value, 
        q_ds_n.concept_id_2 as numerator_unit_concept_id,
        nvl(q_ds.denominator_value, 1)*nvl(q_ds_d.conversion_factor, 1) as denominator_value, 
        q_ds_d.concept_id_2 as denominator_unit_concept_id,
        coalesce(q_ds_a.precedence, q_ds_n.precedence, q_ds_d.precedence) as u_prec
      from (
        select distinct css.concept_code as drug_concept_code, uds.ingredient_concept_code, uds.amount_value, uds.amount_unit, 
          uds.numerator_value*case css.denominator_value when 0 then 1 else denominator_value end as numerator_value, -- reconstitue full quantified 
          uds.numerator_unit, 
          case css.denominator_value when 0 then 1 else denominator_value end as denominator_value,
          uds.denominator_unit 
        from complete_concept_stage css join ds_combo dc on dc.combo_code=css.d_combo_code join ds on dc.concept_code=ds.concept_code join unique_ds uds on uds.ds_code=ds.ds_code
      ) q_ds
      left join relationship_to_concept q_ds_a on q_ds_a.concept_code_1=q_ds.amount_unit -- amount units
      left join relationship_to_concept q_ds_n on q_ds_n.concept_code_1=q_ds.numerator_unit -- numerator units
      left join relationship_to_concept q_ds_d on q_ds_d.concept_code_1=q_ds.denominator_unit -- denominator units
    ), r as (
    -- drug_strength of r
      select distinct
        r_ds.drug_concept_id, r_ds.ingredient_concept_id, 
        r_ds.amount_value, r_ds.amount_unit_concept_id,
        r_ds.numerator_value, r_ds.numerator_unit_concept_id,
        nvl(r_ds.denominator_value, 1) as denominator_value, -- Quantified have a value in the denominator, the others haven't.
        r_ds.denominator_unit_concept_id
      from drug_strength r_ds 
    )
    select 
      q_dcode, q_icode, r_did, r_iid, nvl(df_prec, 100) as df_prec, nvl(bn_prec, 100) as bn_prec, nvl(u_prec, 100) as u_prec, i_prec,
      case when div>1 then 1/div else div end as div, -- the one the closest to 1 wins, but the range is 0-1, which is the opposite direction of the other ones
      unit as u_match, rc_cnt
    from (
      select distinct m.*, case when r.drug_concept_id is null then 0 else q.u_prec end as u_prec,
        case
          when r.drug_concept_id is null then 1 -- if no drug_strength exist (Drug Forms etc.)
          when q.amount_value!=0 and r.amount_value is not null then q.amount_value/r.amount_value
          when q.numerator_unit_concept_id=8554 and r.numerator_unit_concept_id=8576 and r.denominator_unit_concept_id=8587 then (q.numerator_value*10)/(r.numerator_value/r.denominator_value) -- % vs mg/mL
          when q.numerator_unit_concept_id=8554 and r.numerator_unit_concept_id!=8554 then (q.numerator_value/100)/(r.numerator_value/r.denominator_value) -- % in one but not in the other
          when q.numerator_unit_concept_id!=8554 and r.numerator_unit_concept_id=8554 then (q.numerator_value/q.denominator_value)/(r.numerator_value/100) -- % in the other but not in one
          when q.numerator_value!=0 and r.numerator_value is not null then (q.numerator_value/q.denominator_value)/(r.numerator_value/r.denominator_value) -- denominator empty unless Quant
        else 0 end as div,
        case 
          when r.drug_concept_id is null then 1 -- if no drug_strength exist (Drug Forms etc.)
          when q.amount_unit_concept_id=r.amount_unit_concept_id then 1
          when q.numerator_unit_concept_id=8554 and r.numerator_unit_concept_id=8576 and r.denominator_unit_concept_id=8587 then 1 -- % vs mg/mL
          when q.numerator_unit_concept_id=8554 and r.numerator_unit_concept_id=r.denominator_unit_concept_id then 1 -- % vs mg/mg or mL/mL
          when q.numerator_unit_concept_id=q.denominator_unit_concept_id and r.numerator_unit_concept_id=8554 then 1 -- g/g, mg/mg or mL/mL vs %
          when q.numerator_unit_concept_id=r.numerator_unit_concept_id and q.denominator_unit_concept_id=r.denominator_unit_concept_id then 1
        else 0 end as unit
      from q_to_r_anydose m
      -- drug strength for each q ingredient
      left join q on q.drug_concept_code=m.q_dcode and q.ingredient_concept_code=m.q_icode
      -- drug strength for each r ingredient 
      left join r on r.drug_concept_id=m.r_did and r.ingredient_concept_id=m.r_iid
    )
    ;
    commit;

    -- Remove all multiple mappings with close divs and keep the best
    delete from q_to_r_wdose
    where rowid in (
      select r from (
        select rowid as r,
          rank() over (partition by q_dcode, q_icode, df_prec, bn_prec, u_prec order by div desc, i_prec) as rn
        from q_to_r_wdose
      )
      where rn > 1    
    )
    ;
    commit;

    -- Remove all those where not everything fits
    --drop table q_to_r purge;
    -- table has to be created separately because both subsequent queries define one field as null
    create table q_to_r nologging as
    select q_dcode, r_did, r_iid, div, bn_prec, df_prec, u_prec, rc_cnt from q_to_r_wdose
    where 1=0;

    insert /*+ APPEND */ into q_to_r
    select 
      a.q_dcode, a.r_did, null as r_iid, a.div, a.bn_prec, a.df_prec, a.u_prec, a.rc_cnt
    from ( -- take the distinct set of drug-drug pairs with the same Brand Name, Dose Form and unit precedence
    -- only for those where multiple ingredients could be contained in the concept (everything but Ingredient and Clin Drug Comp)
      select q_dcode, r_did, avg(div) as div, bn_prec, df_prec, u_prec, rc_cnt, count(8) as cnt from q_to_r_wdose where nvl(rc_cnt, 0)>1 
      group by q_dcode, r_did, bn_prec, df_prec, u_prec, rc_cnt
    ) a
    -- but make sure there are sufficient amount of components (ingredients) in each group
    where a.cnt=a.rc_cnt
    group by a.q_dcode, a.r_did, a.div, a.bn_prec, a.df_prec, a.u_prec, a.rc_cnt
    -- not one of the components should miss the match
    having not exists (
      select 1 
      from q_to_r_wdose m -- join the set of the same 
      where a.q_dcode=m.q_dcode and a.r_did=m.r_did
      and a.bn_prec=m.bn_prec and a.df_prec=m.df_prec and a.u_prec=m.u_prec
    -- Change the factor closer to 1 if matching should be tighter. Currently, anything within 10% amount will be considered a match.
      and (m.div<0.9 or m.u_match=0)
    )
    ;
    commit;

    -- Second step add Clinical Drug Components
    insert /*+ APPEND */ into q_to_r
    select distinct q_dcode, r_did, r_iid, div, bn_prec, df_prec, u_prec, null as rc_cnt
    from q_to_r_wdose
    where nvl(rc_cnt, 1)=1 -- process only those that don't have combinations (Clin Drug Components)
    and div>=0.9 and u_match=1
    ;
    commit;

    -- Remove mappings to multiple equally good matches
    delete from q_to_r
    where rowid in (
      select r from (
        select rowid as r,
          row_number() over (partition by q_dcode order by div desc, df_prec, bn_prec, u_prec) as rn
        from q_to_r
      )
      where rn > 1    
    )
    ;
    commit; 


    -- 5. Write out result tables

    truncate table concept_stage;
    truncate table concept_relationship_stage;
    truncate table drug_strength_stage;
    delete from existing_ds where vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1);

    -- Write Ingredients, Brand Names, Dose Forms

    insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
    select 
      null as concept_id, 
      dcs.concept_name, -- take concept_name from equivalent 
      'Drug' as domain_id,
      dcs.vocabulary_id,
      dcs.concept_class_id,
      null as standard_concept, -- DA_France ingreidents are not standard, unless they are not mapped
      dcs.concept_code,
      nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=dcs.vocabulary_id)) as valid_start_date,
      nvl(dcs.valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
      invalid_reason
    from drug_concept_stage dcs where dcs.concept_class_id in ('Ingredient', 'Dose Form', 'Brand Name') and dcs.domain_id='Drug';

    commit;

    -- insert suppliers
    insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
    select 
      null as concept_id, 
      dcs.concept_name, -- take concept_name from equivalent 
      'Drug' as domain_id,
      dcs.vocabulary_id,
      'Supplier' as  concept_class_id,
      null as standard_concept, -- DA_France ingreidents are not standard, unless they are not mapped
      dcs.concept_code,
      nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=dcs.vocabulary_id)) as valid_start_date,
      nvl(dcs.valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
      invalid_reason 
    from drug_concept_stage dcs where dcs.concept_class_id = 'Supplier' and dcs.domain_id='Drug';
    commit;

    -- Promote non-mapped Ingredients to Standard
    update concept_stage set standard_concept='S' where concept_code not in (select concept_code_1 from relationship_to_concept) and concept_class_id='Ingredient' and invalid_reason is null;

    -- Write concepts from complete_concept_stage
    insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
    select distinct
      null as concept_id, 
      cn.concept_name,
      'Drug' as domain_id,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id,
      css.concept_class_id,
      case when qr.q_dcode is null and dcs.invalid_reason is null then 'S' else null end as standard_concept, -- Standard Concept unless there is a map to RxNorm 
      css.concept_code,
      nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1))) as valid_start_date,
      nvl(dcs.valid_end_date, to_date('2099-12-31', 'yyyy-mm-dd')) as valid_end_date,
      invalid_reason
    from complete_concept_stage css
    join complete_name cn on cn.concept_code=css.concept_code
    left join drug_concept_stage dcs on dcs.concept_code=css.concept_code
    left join q_to_r qr on qr.q_dcode=css.concept_code
    where (qr.q_dcode is null or css.concept_code not like 'XXX%') -- concepts that cannot be mapped and therefore are standard or those we got from the source
    and nvl(dcs.domain_id, 'Drug')='Drug';

    commit; 

    -- Write equivalents from q to r Ingredients
    -- Pick either the ingredient that was actually matched or the one with precedence 1
    -- CHECK OUT: The former may not be unambiguous.
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select distinct 
      concept_code_1,
      q.vocabulary_id,
      nvl(m.concept_code, first_value(r.concept_code) over (partition by concept_code_1 order by nvl(precedence, 1))) as concept_code_2, -- pick the one actually mapped or the one with the best precedence
      nvl(m.vocabulary_id, first_value(r.vocabulary_id) over (partition by concept_code_1 order by nvl(precedence, 1))) as vocabulary_id_2,
      'Has standard ing' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from drug_concept_stage q
    join relationship_to_concept on concept_code_1=q.concept_code
    join concept r on r.concept_id=concept_id_2
    left join (
      select q_icode, rm.concept_code, rm.vocabulary_id -- mostly RxNorm
      from (
        select distinct q_icode, r_iid from q_to_r_wdose  -- instead of taking precedence 1 take the one that is actually found to map
      )
      join concept rm on rm.concept_id=r_iid
    ) m on m.q_icode=q.concept_code
    where q.concept_class_id = 'Ingredient' and q.domain_id='Drug'
    ;
    commit;

    -- Write equivalents from q to r Brand Name
    -- CHECK OUT: There may be more than one Brand Name mapped. In that case, use q_to_r_wdose, map the Brand Name to q_dcode and pick the most frequent precedence (instead of 1)
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select distinct 
      concept_code_1,
      q.vocabulary_id,
      first_value(r.concept_code) over (partition by concept_code_1 order by nvl(precedence, 1)) as concept_code_2, -- pick the one with the best precedence
      first_value(r.vocabulary_id) over (partition by concept_code_1 order by nvl(precedence, 1)) as vocabulary_id_2,
      'Has standard brand' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from drug_concept_stage q
    join relationship_to_concept on concept_code_1=q.concept_code
    join concept r on r.concept_id=concept_id_2
    where q.concept_class_id='Brand Name' and q.domain_id='Drug'
    ;
    commit;

    -- Write equivalents from q to r Dose Form
    -- CHECK OUT: should not be precedence 1 Dose Form but the one that is mostly mapped. Use q_to_r_wdose and use a similar alogirthm as for building q_to_r
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select distinct 
      concept_code_1,
      q.vocabulary_id,
      first_value(r.concept_code) over (partition by concept_code_1 order by nvl(precedence, 1)) as concept_code_2,
      first_value(r.vocabulary_id) over (partition by concept_code_1 order by nvl(precedence, 1)) as vocabulary_id_2,
      'Has standard form' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from drug_concept_stage q
    join relationship_to_concept on concept_code_1=q.concept_code
    join concept r on r.concept_id=concept_id_2
    where q.concept_class_id='Dose Form' and q.domain_id='Drug'
    ;
    commit;

    -- Write maps from concept_stage to RxNorm as Maps to
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select 
      qr.q_dcode as concept_code_1,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
      c.concept_code concept_code_2,
      c.vocabulary_id as vocabulary_id_2,
      'Maps to' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    -- usual validity
    from q_to_r qr
    join concept_stage cs on cs.concept_code=qr.q_dcode -- limit to those that actually were written to concept_stage (either source codes or standard_concept='S')
    join concept c on c.concept_id=qr.r_did
    ;
    commit;

    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select distinct 
      concept_code concept_code_1,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
      mf_code as concept_code_2,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_2,
      'Has supplier' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from complete_concept_stage q
    where concept_class_id = 'Marketed Product';
    commit;

    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select distinct
      ccs1.concept_code as concept_code_1,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id,
      ccs2.concept_code as concept_code_2,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id,
      'Marketed form of' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from complete_concept_stage ccs1 JOIN nmf_packs nmf ON nmf.concept_code=ccs1.concept_code JOIN complete_concept_stage ccs2 ON ccs2.concept_code=nmf.nmf_code;
    commit;

    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select distinct
      ccs1.concept_code as concept_code_1,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id,
      ccs2.concept_code as concept_code_2,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id,
      'Marketed form of' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from complete_concept_stage ccs1 
    JOIN complete_concept_stage ccs2 
    ON  nvl(ccs1.denominator_value, 0) = nvl(ccs2.denominator_value, 0) 
    AND ccs1.i_combo_code = ccs2.i_combo_code 
    AND ccs1.d_combo_code = ccs2.d_combo_code 
    AND ccs1.dose_form_code = ccs2.dose_form_code 
    AND nvl(ccs1.brand_code, ' ') = nvl(ccs2.brand_code, ' ') 
    AND nvl(ccs1.box_size, 0) = nvl(ccs2.box_size, 0)
    where ccs1.concept_class_id='Marketed Product' AND ccs2.concept_class_id NOT IN ('Marketed Product')
    AND ccs1.i_combo_code != ' ' AND ccs1.d_combo_code != ' ' AND ccs1.dose_form_code != ' ';
    commit;

    -- write RxNorm-like relationships between concepts of all classes except Drug Forms and Clinical Drug Component based on matching components
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    with rl as (
    -- Pull relationship_id between concept classes from existing RxNorm
      select distinct c1.concept_class_id as concept_class_id_1, r.relationship_id, c2.concept_class_id as concept_class_id_2
      from concept c1
      join concept_relationship r on r.concept_id_1=c1.concept_id and r.invalid_reason is null 
        and relationship_id not in ('Precise ing of', 'Reformulated in', 'RxNorm replaces', 'Maps to', 'Concept replaces', 'Has precise ing', 'Mapped from', 'Reformulation of', 'RxNorm replaced by', 'Concept replaced by', 'Contained in')
      join relationship rl on rl.relationship_id=r.relationship_id and rl.defines_ancestry=1
      join concept c2 on c2.concept_id=r.concept_id_2
      where c1.vocabulary_id='RxNorm' and c2.vocabulary_id='RxNorm'
        and c1.concept_class_id not in ('Brand Name', 'Dose Form', 'Ingredient', 'Clinical Drug Form', 'Branded Drug Form', 'Clinical Drug Comp', 'Branded Pack', 'Clinical Pack') 
    -- Add non-RxNorm concept_classes
    union
      select 'Branded Drug Box', 'Has quantified form', 'Quant Branded Box' from dual
    union
      select 'Clinical Drug Box', 'Has quantified form', 'Quant Clinical Box' from dual
    union
      select 'Clinical Drug Box', 'Has tradename', 'Branded Drug Box' from dual
    union
      select 'Quant Clinical Box', 'Has tradename', 'Quant Branded Box' from dual
    union
      select 'Clinical Drug', 'Available as box', 'Clinical Drug Box' from dual
    union
      select 'Branded Drug', 'Available as box', 'Branded Drug Box' from dual
    union
      select 'Quant Clinical Drug', 'Available as box', 'Quant Clinical Box' from dual
    union
      select 'Quant Branded Drug', 'Available as box', 'Quant Branded Box' from dual
    )
    select
      an.concept_code as concept_code_1, -- Use the RxNorm if available
      an.vocabulary_id as vocabulary_id_1,
      de.concept_code as concept_code_2,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_2,
      rl.relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    -- get ancestors: RxNorm or DPD
    from (
      select nvl(r_code, concept_code) as concept_code, nvl(r_vocab_id, (select vocabulary_id from drug_concept_stage where rownum=1)) as vocabulary_id, 
        case denominator_value when 0 then null else denominator_value end as denominator_value, 
        d_combo_code, 
        case dose_form_code when ' ' then null else dose_form_code end as dose_form_code, 
        case brand_code when ' ' then null else brand_code end as brand_code, 
        case box_size when 0 then null else box_size end as box_size,
        concept_class_id
      from complete_concept_stage
    -- use RxNorm if mapped
      left join (
        select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab_id from q_to_r qr join concept r on r.concept_id=qr.r_did
      ) on q_dcode=concept_code
      where concept_class_id not in ('Brand Name', 'Dose Form', 'Ingredient', 'Clinical Drug Form', 'Branded Drug Form', 'Clinical Drug Comp', 'Branded Pack', 'Clinical Pack', 'Marketed Product')
    ) an 
    join rl on rl.concept_class_id_1=an.concept_class_id
    join complete_concept_stage de
    on de.denominator_value=coalesce(an.denominator_value, de.denominator_value, 0) 
      and de.dose_form_code=coalesce(an.dose_form_code, de.dose_form_code, ' ') 
      and de.brand_code=coalesce(an.brand_code, de.brand_code, ' ') and de.box_size=coalesce(an.box_size, de.box_size, 0)
      and de.d_combo_code=an.d_combo_code
      and de.concept_code!=an.concept_code 
      and de.concept_class_id!=an.concept_class_id
      and de.concept_class_id not in ('Brand Name', 'Dose Form', 'Ingredient', 'Clinical Drug Form', 'Branded Drug Form', 'Clinical Drug Comp', 'Branded Pack', 'Clinical Pack', 'Marketed Product')
      and de.concept_code not in (select q_dcode from q_to_r) -- the descendant cannot be RxNorm, as all RxNorm have RxNorm ancestors
      and rl.concept_class_id_2=de.concept_class_id
    ;
    commit;

    -- For speed up pull out indexed table
    --drop table an purge;
    create table an nologging as
    select
      nvl(r_code, concept_code) as concept_code, nvl(r_vocab_id, (select vocabulary_id from drug_concept_stage where rownum=1)) as vocabulary_id, 
      i_combo_code,
      d_combo_code,
      replace (dose_form_code, ' ', '') as dose_form_code, 
      replace (brand_code, ' ', '') as brand_code, 
      concept_class_id
    from complete_concept_stage
    left join (
      select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab_id from q_to_r qr join concept r on r.concept_id=qr.r_did
    ) on q_dcode=concept_code
    where concept_class_id in ('Clinical Drug Form', 'Branded Drug Form', 'Clinical Drug Comp')
    ;
    create index x_an on an(i_combo_code);
    commit;
    exec DBMS_STATS.GATHER_TABLE_STATS (ownname=> USER, tabname => 'complete_concept_stage', estimate_percent => null, degree =>4, cascade => true);
    -- Write RxNorm-like relationships for Clinical Drug Forms (matching ingredient combinations)

    create table rl as (
      select distinct r.relationship_id, c2.concept_class_id as concept_class_id_2
      from concept c1
      join concept_relationship r on r.concept_id_1=c1.concept_id and r.invalid_reason is null 
        and relationship_id not in ('Precise ing of', 'Reformulated in', 'RxNorm replaces', 'Maps to', 'Concept replaces', 'Has precise ing', 'Mapped from', 'Reformulation of', 'RxNorm replaced by', 'Concept replaced by', 'Contained in')
      join relationship rl on rl.relationship_id=r.relationship_id and rl.defines_ancestry=1
      join concept c2 on c2.concept_id=r.concept_id_2
      where c1.vocabulary_id='RxNorm' and c2.vocabulary_id='RxNorm'
        and c1.concept_class_id = 'Clinical Drug Form'
    ) 
    ;

    create table de as (
      select de.concept_code as de_code, de.concept_class_id as de_class_id,
        an.concept_code as an_code, an.concept_class_id as an_class_id, an.vocabulary_id as an_vocab_id
      from complete_concept_stage de 
      join an on de.i_combo_code=an.i_combo_code 
      and an.concept_code!=de.concept_code 
      and de.dose_form_code=coalesce(an.dose_form_code, de.dose_form_code, ' ') 
      and de.concept_code!=an.concept_code
      and an.concept_class_id='Clinical Drug Form'
      where de.concept_code not in (select q_dcode from q_to_r) -- the descendant cannot be RxNorm, as all RxNorm have RxNorm ancestors  
    ) 
    ;
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    -- Pull relationship_id between concept classes from existing RxNorm

    select
      an_code as concept_code_1,
      an_vocab_id as vocabulary_id_1,
      de_code as concept_code_2,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_2,
      rl.relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from rl 
    join de on rl.concept_class_id_2=de.de_class_id
    ;
    commit;

    -- write RxNorm-like relationships for Branded Drug Forms (matching ingredient combinations)
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select 
      an.concept_code as concept_code_1,
      an.vocabulary_id as vocabulary_id_1,
      de.concept_code as concept_code_2,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_2,
      'RxNorm inverse is a' as relationship_id, -- Need to take RxNorm out of these
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from complete_concept_stage de
    join an on de.i_combo_code=an.i_combo_code and an.concept_code!=de.concept_code and an.concept_class_id='Branded Drug Form'
    where de.concept_class_id in ('Branded Drug', 'Quant Branded Drug')
      and de.dose_form_code=coalesce(an.dose_form_code, de.dose_form_code, ' ')
      and de.brand_code=an.brand_code
      and de.concept_code not in (select q_dcode from q_to_r) -- the descendant cannot be RxNorm, as all RxNorm have RxNorm ancestors  
    ;
    commit;

    -- Write relationship between Clinical Drug Comp (single Ingredient)
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    -- Pull relationship_id between concept classes from existing RxNorm
    with rl as (
      select distinct c1.concept_class_id as concept_class_id_1, r.relationship_id, c2.concept_class_id as concept_class_id_2
      from concept c1
      join concept_relationship r on r.concept_id_1=c1.concept_id and r.invalid_reason is null 
        and relationship_id not in ('Precise ing of', 'Reformulated in', 'RxNorm replaces', 'Maps to', 'Concept replaces', 'Has precise ing', 'Mapped from', 'Reformulation of', 'RxNorm replaced by', 'Concept replaced by', 'Contained in')
      join relationship rl on rl.relationship_id=r.relationship_id and rl.defines_ancestry=1
      join concept c2 on c2.concept_id=r.concept_id_2
      where c1.vocabulary_id='RxNorm' and c2.vocabulary_id='RxNorm'
        and c1.concept_class_id = 'Clinical Drug Comp'
    ) 
    select 
      an.concept_code as concept_code_1,
      an.vocabulary_id as vocabulary_id_1,
      de.concept_code as concept_code_2,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_2,
      rl.relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from complete_concept_stage de
    join (
      select distinct 'X'|| dc.combo_code as combo_code,'X'|| ds.ds_code as ds_code
      from ds_combo dc join ds on ds.concept_code=dc.concept_code
    ) d on 'X'|| de.d_combo_code=d.combo_code
    join an on d.ds_code='X'|| an.d_combo_code and an.concept_code!=de.concept_code and an.concept_class_id='Clinical Drug Comp'
    join rl on rl.concept_class_id_2=de.concept_class_id 
    where de.concept_code not in (select q_dcode from q_to_r) -- the descendant cannot be RxNorm, as all RxNorm have RxNorm ancestors  
    ;
    commit;

    -- remove duplications occurring when ds_stage has entries that are fully 0
    delete from concept_relationship_stage where rowid not in (select max(rowid) from concept_relationship_stage group by concept_code_1, concept_code_2, relationship_id);
    commit;

    -- Write relationship between Drugs and Packs
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select 
      nmfp.nmf_code as concept_code_1,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
      nvl(r_code, p.drug_concept_code) as concept_code_2,
      nvl(r_vocab_id, (select vocabulary_id from drug_concept_stage where rownum=1)) as vocabulary_id_2,
      'Contains',
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from nmf_packs nmfp 
    JOIN pack_content p ON p.pack_concept_code=nmfp.concept_code
    left join (
      select qr.q_dcode, r.concept_code as r_code, r.vocabulary_id as r_vocab_id from q_to_r qr join concept r on r.concept_id=qr.r_did
    ) on q_dcode=p.drug_concept_code
    ;
    commit;

    -- Write relationships between Ingredients and Clinical Drug Form and Clinical Drug Component (no Ingredient combinations)
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select distinct
      nvl(crs.concept_code_2, i.concept_code) as concept_code_1,
      nvl(crs.vocabulary_id_2, (select vocabulary_id from drug_concept_stage where rownum=1)) as vocabulary_id_1,
      ccs.concept_code as concept_code_2,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_2,
      'RxNorm ing of' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from complete_concept_stage ccs
    join (
      select distinct ic.combo_code, ing.ing_code as concept_code 
      from ing_combo ic join ing on ing.concept_code=ic.concept_code
    ) i on ccs.i_combo_code=i.combo_code
    left join concept_relationship_stage crs on crs.concept_code_1=i.concept_code -- join a mapped Ingredient if exists
    where ccs.concept_class_id in ('Clinical Drug Form', 'Clinical Drug Comp')
    --and   nvl(crs.concept_code_2, i.concept_code)='1007302'
    ;
    commit;

    -- Write relationships between all of them and Dose Form
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select 
      ccs.concept_code as concept_code_1,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
      ccs.dose_form_code as concept_code_2,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_2,
      'RxNorm has dose form' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from complete_concept_stage ccs
    join concept_stage cs on cs.concept_code=ccs.concept_code
    where ccs.dose_form_code is not null AND ccs.mf_code is null;

    commit;

    -- Write relationships between all of them and Brand Name
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select 
      ccs.concept_code as concept_code_1,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
      ccs.brand_code as concept_code_2,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_2,
      'RxNorm has ing' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from complete_concept_stage ccs
    join concept_stage cs on cs.concept_code=ccs.concept_code
    where ccs.brand_code is not null and ccs.mf_code = ' '
    ;
    commit;

    -- Write maps from drugs that didn't make it into complete_concept_stage but have drug strength (duplicates)
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select 
      e.concept_code as concept_code_1,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
      nvl(r.concept_code, c.concept_code) as concept_code_2, -- if mapped to RxNorm prefer that
      nvl(r.vocabulary_id, (select vocabulary_id from drug_concept_stage where rownum=1)) as vocabulary_id_2,
      'Maps to' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from existing_concept_stage e 
    join complete_concept_stage c on c.denominator_value=e.denominator_value and c.i_combo_code=e.i_combo_code and c.d_combo_code=e.d_combo_code 
      and c.dose_form_code=e.dose_form_code and c.brand_code=e.brand_code and c.box_size=e.box_size and c.mf_code = e.mf_code and e.concept_code!=c.concept_code
    -- try a map to RxNorm
    left join (
      select qr.q_dcode, r.concept_code, r.vocabulary_id from q_to_r qr join concept r on r.concept_id=qr.r_did
    ) r on r.q_dcode=c.concept_code
    ;
    commit;

    -- Write missing drugs that never made it into complete_concept_stage but have drug_strength (duplicates)
    insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
    select 
      null as concept_id, 
      cn.concept_name, -- steal concept_name from equivalent 
      'Drug' as domain_id,
      (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id,
      e.concept_class_id,
      null as standard_concept,
      e.concept_code,
      nvl(dcs.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1))) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      invalid_reason
    from existing_concept_stage e 
    join complete_concept_stage c on c.denominator_value=e.denominator_value and c.i_combo_code=e.i_combo_code and c.d_combo_code=e.d_combo_code 
      and c.dose_form_code=e.dose_form_code and c.brand_code=e.brand_code and c.box_size=e.box_size and c.mf_code=e.mf_code
    left join complete_concept_stage c2 on c2.concept_code=e.concept_code
    join complete_name cn on cn.concept_code=c.concept_code
    join drug_concept_stage dcs on dcs.concept_code=e.concept_code and dcs.domain_id='Drug'
    where e.concept_code!=c.concept_code AND c2.concept_code is null;
    ;
    commit;

    -- Write links to Ingredients for drugs not covered by drug_strength (added next)
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select distinct
      m.concept_code as concept_code_1,
      dcs.vocabulary_id as vocabulary_id_1,
      nvl(crs.concept_code_2, dcs.concept_code) as concept_code_2,
      nvl(crs.vocabulary_id_2, dcs.vocabulary_id) as vocabulary_id_2,
      'RxNorm has ing' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from (
      select concept_code from drug_concept_stage where (concept_class_id like '%Drug%') and domain_id='Drug'
      minus
      select concept_code from concept_stage 
    ) m
    join internal_relationship_stage r on r.concept_code_1=m.concept_code
    join drug_concept_stage dcs on dcs.concept_code=r.concept_code_2 and dcs.concept_class_id='Ingredient' and dcs.domain_id='Drug'
    left join concept_relationship_stage crs on crs.concept_code_1=dcs.concept_code -- join a mapped Ingredient if exists
    ;
    commit;

    -- Write links to Dose Forms for drugs not covered by drug_strength (added next)
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select 
      m.concept_code as concept_code_1,
      dcs.vocabulary_id as vocabulary_id_1,
      dcs.concept_code as concept_code_2,
      dcs.vocabulary_id as vocabulary_id_2,
      'RxNorm has dose form' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from (
      select concept_code from drug_concept_stage where (concept_class_id like '%Drug%') and domain_id='Drug'
      minus
      select concept_code from concept_stage 
    ) m
    join internal_relationship_stage r on r.concept_code_1=m.concept_code
    join drug_concept_stage dcs on dcs.concept_code=r.concept_code_2 and dcs.concept_class_id='Dose Form' and dcs.domain_id='Drug'
    ;
    commit;

    -- Write links to Brand Names for drugs not covered by drug_strength (added next)
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select 
      m.concept_code as concept_code_1,
      dcs.vocabulary_id as vocabulary_id_1,
      dcs.concept_code as concept_code_2,
      dcs.vocabulary_id as vocabulary_id_2,
      'RxNorm has ing' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from (
      select concept_code from drug_concept_stage where (concept_class_id like '%Drug%') and domain_id='Drug'
      minus
      select concept_code from concept_stage 
    ) m
    join internal_relationship_stage r on r.concept_code_1=m.concept_code
    join drug_concept_stage dcs on dcs.concept_code=r.concept_code_2 and dcs.concept_class_id='Brand Name' and dcs.domain_id='Drug'
    ;
    commit;

    -- Write drugs not covered by drug_strength
    insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
    select 
      null as concept_id, 
      c.concept_name, -- take concept_name from equivalent 
      'Drug' as domain_id,
      c.vocabulary_id,
      c.concept_class_id,
     'S' as standard_concept,
      c.concept_code,
      nvl(c.valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1))) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      invalid_reason
    from (
      select concept_code from drug_concept_stage where (concept_class_id like '%Drug%') and domain_id='Drug'
      minus
      select concept_code  from concept_stage 
    ) m
    join drug_concept_stage c on c.concept_code=m.concept_code and c.domain_id='Drug'
    ;
    commit;

    -- Write relationship to drug classes
    insert /*+ APPEND */ into concept_relationship_stage (concept_code_1, vocabulary_id_1, concept_code_2, vocabulary_id_2, relationship_id, valid_start_date, valid_end_date, invalid_reason)
    select 
      c1.concept_code as concept_code_1,
      c1.vocabulary_id as vocabulary_id_1,
      c2.concept_code as concept_code_2,
      c2.vocabulary_id as vocabulary_id_2,
      'Drug has drug class' as relationship_id,
      (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)) as valid_start_date,
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      null as invalid_reason
    from drug_concept_stage c1
    join relationship_to_concept r on r.concept_code_1=c1.concept_code 
    join concept c2 on c2.concept_id=r.concept_id_2
    where c2.vocabulary_id in (select distinct vocabulary_id from concept where domain_id='Drug' and standard_concept='C')
    and c1.concept_class_id in ('Branded Drug Box', 'Branded Drug Comp', 'Quant Clinical Drug', 'Branded Pack', 'Clinical Drug Box', 'Clinical Pack', 'Clinical Drug Form', 'Quant Branded Drug', 'Clinical Drug', 'Branded Drug Form', 'Quant Branded Box', 'Branded Drug', 'Clinical Drug Comp', 'Quant Clinical Box')
    ;
    commit;

    -- non drugs
    insert /*+ APPEND */ into concept_stage (concept_id, concept_name, domain_id, vocabulary_id, concept_class_id, standard_concept, concept_code, valid_start_date, valid_end_date, invalid_reason)
    select
      null as concept_id,
      concept_name,
      domain_id,
      vocabulary_id,
      concept_class_id,
    case when invalid_reason is null then 'S' else null end as standard_concept,
      concept_code,
      nvl(valid_start_date, (select latest_update from vocabulary v where v.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1))) as valid_start_date, 
      to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date,
      invalid_reason
    from drug_concept_stage where domain_id!='Drug'
    ; 
    commit;


    -- 7. Create DRUG_STRENGTH from unique_ds

    -- collect statistics so Oracle does the following in a reasonable approach
    exec DBMS_STATS.GATHER_TABLE_STATS (ownname => USER, tabname  => 'concept_stage', estimate_percent  => null, cascade  => true);
    exec DBMS_STATS.GATHER_TABLE_STATS (ownname => USER, tabname  => 'ds', estimate_percent  => null, cascade  => true);
    exec DBMS_STATS.GATHER_TABLE_STATS (ownname => USER, tabname  => 'complete_concept_stage', estimate_percent  => null, cascade  => true);

    create table q_ds as 
    select css.concept_code as drug_concept_code, 
            uds.ingredient_concept_code,
            uds.amount_value, uds.amount_unit, 
            uds.numerator_value*case css.denominator_value when 0 then 1 else denominator_value end as numerator_value, -- reconstitue full quantified 
            uds.numerator_unit,
            css.denominator_value, uds.denominator_unit,
            cs.valid_start_date
          from unique_ds uds join ds on uds.ds_code=ds.ds_code join ds_combo dc on dc.concept_code=ds.concept_code 
          join complete_concept_stage css on css.d_combo_code=dc.combo_code and css.concept_class_id!='Clinical Drug Comp' -- in Clinical Drug Comp no combinations of ds_codes
          join concept_stage cs on cs.concept_code=css.concept_code
        union
          select css.concept_code as drug_concept_code,
            uds.ingredient_concept_code, uds.amount_value, uds.amount_unit, 
            uds.numerator_value, uds.numerator_unit, 
            null as denominator_value, uds.denominator_unit,
            cs.valid_start_date
          from unique_ds uds join ds on 'X'||uds.ds_code='X'||ds.ds_code join ds_combo dc on dc.concept_code=ds.concept_code 
          join complete_concept_stage css on 'X'||css.d_combo_code='X'||ds.ds_code and css.concept_class_id='Clinical Drug Comp' -- in Clinical Drug Comp no combinations of ds_codes
          join concept_stage cs on cs.concept_code=css.concept_code
        ;

        create table q_ds_i as
        (
          select r.concept_code_1, r.precedence, i.concept_code as ingredient_concept_code, i.vocabulary_id as ingredient_vocabulary_id
          from relationship_to_concept r join concept i on i.concept_id=r.concept_id_2
          where nvl(r.precedence, 1)=1
        ) 
        ;
   
        create table q_ds_q_ds_i as
    
    (
    -- select details, but with wrong null ids
        select distinct 
          q_ds.drug_concept_code, 
          nvl(q_ds_i.ingredient_concept_code, q_ds.ingredient_concept_code) as ingredient_concept_code, q_ds_i.ingredient_vocabulary_id,
          q_ds.amount_value*q_ds_a.conversion_factor as amount_value, 
          q_ds_a.concept_id_2 as amount_unit_concept_id, 
          q_ds.numerator_value*q_ds_n.conversion_factor as numerator_value, 
          q_ds_n.concept_id_2 as numerator_unit_concept_id,
          nvl(q_ds.denominator_value, 1)*q_ds_d.conversion_factor as denominator_value, 
          q_ds_d.concept_id_2 as denominator_unit_concept_id,
          q_ds.valid_start_date
        from  q_ds
        left join relationship_to_concept q_ds_a on q_ds_a.concept_code_1=q_ds.amount_unit and nvl(q_ds_a.precedence, 1)=1 -- amount units
        left join relationship_to_concept q_ds_n on q_ds_n.concept_code_1=q_ds.numerator_unit and nvl(q_ds_n.precedence, 1)=1 -- numerator units
        left join relationship_to_concept q_ds_d on q_ds_d.concept_code_1=q_ds.denominator_unit and nvl(q_ds_d.precedence, 1)=1 -- denominator units
        left join  q_ds_i on q_ds_i.concept_code_1=q_ds.ingredient_concept_code and coalesce(q_ds_a.concept_code_1, q_ds_n.concept_code_1, q_ds_d.concept_code_1) is not null
      )
        ;
       insert /*+ APPEND */ into drug_strength_stage
    -- dedup same ingredient in product and sum up the amounts
    select drug_concept_code, vocabulary_id_1, ingredient_concept_code, vocabulary_id_2,
      sum(amount_value) as amount_value,
      amount_unit_concept_id,
      sum(numerator_value) as numerator_value,
      numerator_unit_concept_id,
      sum(denominator_value) as denominator_value,
      denominator_unit_concept_id, valid_start_date, valid_end_date, invalid_reason
    from (
    -- create ds records
      select 
        drug_concept_code, (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id_1,
        ingredient_concept_code, nvl(ingredient_vocabulary_id, (select vocabulary_id from drug_concept_stage where rownum=1)) as vocabulary_id_2,
        case amount_value when 0 then null else amount_value end as amount_value, amount_unit_concept_id,
        case numerator_value when 0 then null else numerator_value end as numerator_value, numerator_unit_concept_id,
        case denominator_value when 0 then null else denominator_value end as denominator_value, denominator_unit_concept_id,
        valid_start_date,
        to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date, null as invalid_reason
      from q_ds_q_ds_i
    )
    group by drug_concept_code, vocabulary_id_1, ingredient_concept_code, vocabulary_id_2, amount_unit_concept_id, numerator_unit_concept_id,
      denominator_unit_concept_id, valid_start_date, valid_end_date, invalid_reason
    ;

    commit;

    -- 8. Tidy up

    -- Replace concept_codes XXX123 with OMOP123
    -- Create replacement map
    --drop table xxx_replace purge;
    create table xxx_replace (
      xxx_code varchar2(50),
      omop_code varchar2(50)
    )
    ;

    -- Replace concept_code with those generated in previous runs of this script: with drug_strength
    insert into xxx_replace
    select distinct
      concept_code as xxx_code, 
      first_value(drug_concept_code) over (partition by concept_code order by drug_concept_code desc) as omop_code -- if more than one pick the "newest"
    from (
      select * 
      from complete_concept_stage 
      join concept_stage using(concept_code)
      where d_combo_code!=' ' 
        and concept_code like 'XXX%'
    )
    join (
      select drug_concept_code, denominator_value, 
        listagg(ds_code, '-') within group (order by ds_code) as d_combo_code, 
        dose_form_code, brand_code, box_size 
      from (
        select drug_concept_code, denominator_value, ingredient_concept_code, ds_code, dose_form_code, brand_code, box_size 
        from unique_ds 
        join (
          select drug_concept_code, denominator_value,
            ingredient_concept_code, amount_value, amount_unit, 
            case numerator_value
              when 0 then 0
              else round(numerator_value/case denominator_value when 0 then 1 else denominator_value end, 3-floor(log(10, numerator_value/case denominator_value when 0 then 1 else denominator_value end))-1) 
            end as numerator_value,
            numerator_unit, denominator_unit,
            dose_form_code, brand_code, box_size 
          from existing_ds where vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)
        ) using(ingredient_concept_code, amount_value, amount_unit, numerator_value, numerator_unit, denominator_unit)
      )
      group by drug_concept_code, denominator_value, dose_form_code, brand_code, box_size 
    ) using(denominator_value, d_combo_code, dose_form_code, brand_code, box_size)
    where regexp_count(i_combo_code, '\-')=regexp_count(d_combo_code, '\-')
    ;

    commit;

    -- without drug_strength (Drug Forms)
    insert into xxx_replace
    select distinct
      concept_code as xxx_code, 
      first_value(drug_concept_code) over (partition by concept_code order by drug_concept_code desc) as omop_code -- if more than one pick the "newest"
    from (
      select * from complete_concept_stage 
      join concept_stage using(concept_code)
      where d_combo_code=' ' 
        and concept_code like 'XXX%'
    )
    join (
      select drug_concept_code, 
        listagg(ingredient_concept_code, '-') within group (order by ingredient_concept_code) as i_combo_code, 
        dose_form_code, brand_code
      from existing_ds 
      where vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)
        and amount_value=0 and amount_unit=' ' and numerator_value=0 and numerator_unit=' ' and denominator_value=0 and denominator_unit=' '
        and box_size=0
      group by drug_concept_code, dose_form_code, brand_code
    ) using(i_combo_code, dose_form_code, brand_code)
    ;

    commit;
drop sequence new_vocab2 ;
   create sequence new_vocab2 increment by 1 start with 252851 nocycle cache 20 noorder;
    -- generate OMOP codes for new concepts
    insert into xxx_replace
    select concept_code as xxx_code, 'OMOP'||new_vocab2.nextval as omop_code
    from concept_stage 
    where concept_code like 'XXX%' 
    and concept_code not in (select xxx_code from xxx_replace)
    ;
    commit;

    -- fast way to update codes require temporary tables. 

    create table cs_rowid_update as
    select cs.rowid as irowid, xr.omop_code as concept_code from xxx_replace xr JOIN concept_stage cs ON cs.concept_code=xr.xxx_code;

    MERGE INTO concept_stage cs
    USING   (
    select * from cs_rowid_update
    ) d ON (d.irowid=cs.rowid)
    WHEN MATCHED THEN UPDATE
        SET cs.concept_code = d.concept_code;

    drop table cs_rowid_update;

    create table crs_rowid_update as
    select distinct crs.rowid as irowid, nvl(xr1.omop_code, crs.concept_code_1) as concept_code_1, nvl(xr2.omop_code, crs.concept_code_2) as concept_code_2 from concept_relationship_stage crs
    LEFT JOIN xxx_replace xr1 ON xr1.xxx_code=crs.concept_code_1 
    LEFT JOIN xxx_replace xr2 ON xr2.xxx_code=crs.concept_code_2
    WHERE xr1.omop_code IS NOT NULL OR xr2.omop_code IS NOT NULL;


    MERGE INTO concept_relationship_stage crs
    USING   (
    select * from crs_rowid_update
    ) d ON (d.irowid=crs.rowid)
    WHEN MATCHED THEN UPDATE
        SET crs.concept_code_1 = d.concept_code_1, crs.concept_code_2 = d.concept_code_2;

    drop table crs_rowid_update;


    create table dss_rowid_update as
    select dss.rowid as irowid, xr.omop_code as drug_concept_code from xxx_replace xr JOIN drug_strength_stage dss ON dss.drug_concept_code=xr.xxx_code;

    MERGE INTO drug_strength_stage dss
    USING   (
    select * from dss_rowid_update
    ) d ON (d.irowid=dss.rowid)
    WHEN MATCHED THEN UPDATE
        SET dss.drug_concept_code = d.drug_concept_code;

    drop table dss_rowid_update;


    commit;

    -- Save ds information for all concepts 
    insert into existing_ds
    select distinct 
      css.concept_code as drug_concept_code, uds.ingredient_concept_code, (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id,
      uds.amount_value, uds.amount_unit, 
      uds.numerator_value*case css.denominator_value when 0 then 1 else denominator_value end as numerator_value, -- reconstitue full quantified 
      uds.numerator_unit, 
      css.denominator_value, -- don't turn 0s into 1s, otherwise we can't distinguish quantified from non-quantified drugs
      uds.denominator_unit,
      css.dose_form_code,
      css.brand_code,
      css.box_size
    from complete_concept_stage css 
    join ds_combo dc on dc.combo_code=css.d_combo_code 
    join ds on dc.concept_code=ds.concept_code 
    join unique_ds uds on uds.ds_code=ds.ds_code
    where css.concept_code like 'XXX%'
    ;
    commit;

    -- Add drug forms (unique_ds available unavailable) 
    insert into existing_ds
    select distinct 
      css.concept_code as drug_concept_code, i.ing_code as ingredient_concept_code, (select vocabulary_id from drug_concept_stage where rownum=1) as vocabulary_id,
      0 as amount_value, ' ' as amount_unit,
      0 as numerator_value, ' ' as numerator_unit, 
      0 as denominator_value, ' ' as denominator_unit,
      css.dose_form_code, css.brand_code, 
      0 as box_size
    from complete_concept_stage css
    join ing_combo ic on ic.combo_code=css.i_combo_code
    join ing i on i.concept_code=ic.concept_code
    where not exists (
      select 1 from existing_ds ed where ed.drug_concept_code=css.concept_code and ed.ingredient_concept_code=i.ing_code and ed.vocabulary_id=(select vocabulary_id from drug_concept_stage where rownum=1)
    )
    and css.concept_code like 'XXX%'
    ;
    commit;

    --Packs fix
    update concept_stage a
    set concept_class_id = 'Branded Pack' where exists (select 1 from concept_relationship_stage z join concept_stage x on x.concept_code = z.concept_code_2 and x.concept_class_id = 'Brand Name' where z.concept_code_1 = a.concept_code)
    and a.concept_class_id = 'Drug Pack'
    ;
    update concept_stage a
    set concept_class_id = 'Clinical Pack' where  a.concept_class_id = 'Drug Pack'
    ;
    commit;

    select count (CONCEPT_CODE_1) from (
    select CONCEPT_CODE_1 from concept_relationship_stage
    group by CONCEPT_ID_1,CONCEPT_ID_2,CONCEPT_CODE_1,CONCEPT_CODE_2,VOCABULARY_ID_1,VOCABULARY_ID_2,RELATIONSHIP_ID,VALID_START_DATE,VALID_END_DATE,INVALID_REASON having count (1) >1
    )
    ;
    --all updated concepts
    insert into concept_relationship_stage (CONCEPT_ID_1,CONCEPT_ID_2,CONCEPT_CODE_1,CONCEPT_CODE_2,VOCABULARY_ID_1,VOCABULARY_ID_2,RELATIONSHIP_ID,VALID_START_DATE,VALID_END_DATE,INVALID_REASON)
    select distinct '','', a.concept_code_1,a.concept_code_2,'dm+d','dm+d','Concept replaced by',to_date('1970-01-01', 'yyyy-mm-dd') as valid_start_date , to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date, null
    from internal_relationship_stage a 
    join drug_concept_stage  b on a.concept_code_1=b.concept_code
    join drug_concept_stage  c on a.concept_code_2=c.concept_code
    where c.concept_class_id= b.concept_Class_id and b.invalid_reason is not null and c.invalid_reason is null;
    ;
    --all ingredients
    insert into concept_relationship_stage (CONCEPT_ID_1,CONCEPT_ID_2,CONCEPT_CODE_1,CONCEPT_CODE_2,VOCABULARY_ID_1,VOCABULARY_ID_2,RELATIONSHIP_ID,VALID_START_DATE,VALID_END_DATE,INVALID_REASON)
    select distinct '','', a.concept_code_1,a.concept_code_2,'dm+d','dm+d','Has standard ing',to_date('1970-01-01', 'yyyy-mm-dd') as valid_start_date , to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date, null
    from internal_relationship_stage a 
    join drug_concept_stage  b on a.concept_code_1=b.concept_code
    join drug_concept_stage  c on a.concept_code_2=c.concept_code
    where c.concept_class_id='Ingredient'
    and b.concept_Class_id='Ingredient'
    and b.invalid_reason is null and c.invalid_reason is  null
    ;
    --all forms
    insert into concept_relationship_stage (CONCEPT_ID_1,CONCEPT_ID_2,CONCEPT_CODE_1,CONCEPT_CODE_2,VOCABULARY_ID_1,VOCABULARY_ID_2,RELATIONSHIP_ID,VALID_START_DATE,VALID_END_DATE,INVALID_REASON)
    select distinct '','', a.concept_code_1,a.concept_code_2,'dm+d','dm+d','Has standard form',to_date('1970-01-01', 'yyyy-mm-dd') as valid_start_date , to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date, null
    from internal_relationship_stage a 
    join drug_concept_stage  b on a.concept_code_1=b.concept_code
    join drug_concept_stage  c on a.concept_code_2=c.concept_code
    where c.concept_class_id='Dose Form'
    and b.concept_Class_id='Dose Form'
    and b.invalid_reason is null and c.invalid_reason is  null;
    ;
    --has standard ingredient with RxNorm
    insert into concept_relationship_stage (CONCEPT_ID_1,CONCEPT_ID_2,CONCEPT_CODE_1,CONCEPT_CODE_2,VOCABULARY_ID_1,VOCABULARY_ID_2,RELATIONSHIP_ID,VALID_START_DATE,VALID_END_DATE,INVALID_REASON)
    select distinct '','', a.concept_code_1,z.concept_code_2,'dm+d','dm+d','Has standard ing',to_date('1970-01-01', 'yyyy-mm-dd') as valid_start_date , to_date('2099-12-31', 'yyyy-mm-dd') as valid_end_date, null
    from concept_relationship_stage a 
    join concept_relationship_stage z on a.concept_code_2 = z.concept_code_1
    join drug_concept_stage  b on a.concept_code_1=b.concept_code
    join drug_concept_stage  c on a.concept_code_2=c.concept_code
    join concept cz on cz.concept_code = z.concept_code_2
    where c.concept_class_id='Ingredient'
    and b.concept_Class_id='Ingredient'
    and cz.concept_class_id = 'Ingredient'
    and z.vocabulary_id_2 = 'RxNorm'
    and b.invalid_reason is null and c.invalid_reason is  null
    ;
    --RxNorm ingredients updated
    --that's all
    create table concept_relationship_stage_tmp as select * from concept_relationship_stage
    ;
    drop table concept_relationship_stage;
    create table concept_relationship_stage as select distinct * from concept_relationship_stage_tmp;
    drop table concept_relationship_stage_tmp purge;
    ;
    commit
    ;
    drop table crs_delete;
    create table crs_delete as
    select cs.concept_code as concept_code_1, cs2.concept_code as concept_code_2 from 
    (select cs.concept_code
    from concept_stage cs 
    LEFT JOIN concept_relationship_stage crs ON crs.CONCEPT_CODE_1=cs.concept_code and crs.RELATIONSHIP_ID ='Marketed form of' 

    WHERE cs.concept_class_id like 'Marketed%' GROUP BY cs.concept_code HAVING count(distinct crs.rowid) != 1) cs 
     join drug_concept_stage a on a.concept_code = cs.concept_code
     JOIN concept_relationship_stage crs ON crs.CONCEPT_CODE_1=cs.concept_code and crs.RELATIONSHIP_ID ='Marketed form of' 
     join drug_concept_stage cs2 on cs2.concept_code = crs.concept_code_2
     and not exists (select 1 from branded_to_clinical bc where bc.concept_code_1 = a.concept_code and bc.concept_code_2 = cs2.concept_code) 
    and cs.concept_code in (
     --those codes need to delete
    select cs.concept_code from 
    (select cs.concept_code
    from concept_stage cs 
    LEFT JOIN concept_relationship_stage crs ON crs.CONCEPT_CODE_1=cs.concept_code and crs.RELATIONSHIP_ID ='Marketed form of' 

    WHERE cs.concept_class_id like 'Marketed%' GROUP BY cs.concept_code HAVING count(distinct crs.rowid) != 1) cs 
     join drug_concept_stage a on a.concept_code = cs.concept_code
     JOIN concept_relationship_stage crs ON crs.CONCEPT_CODE_1=cs.concept_code and crs.RELATIONSHIP_ID ='Marketed form of' 
     join drug_concept_stage cs2 on cs2.concept_code = crs.concept_code_2
     and exists (select 1 from branded_to_clinical bc where bc.concept_code_1 = a.concept_code and bc.concept_code_2 = cs2.concept_code) 
     )
     ;
     delete from concept_relationship_stage a where exists (select 1 from 
    crs_delete b where a.concept_code_1 = b.concept_code_1 and a.concept_code_2 = b.concept_code_2)
    ;
    drop table dmd_map_tmp ;
    create table dmd_map_tmp as
    select a.* from concept_relationship_stage a
    join concept_Stage b on a.concept_code_2 = b.concept_code and b.invalid_reason is  null
    and relationship_id = 'Maps to'
    where relationship_id = 'Maps to'
    and vocabulary_id_1 = 'dm+d' and vocabulary_id_2='dm+d'
    and cast ( concept_code_1 as int)>  cast (concept_code_2 as int)
    ;
    drop table dmd_map_tmp_2;
    creAte table dmd_map_tmp_2 as
    select concept_code_1, concept_code_2, 
    RANK() over (partition by concept_code_1  ORDER BY cast (concept_code_2 as int) ) as rnk
    from dmd_map_tmp
    ;
    drop table dmd_map_tmp_fin;
    create table dmd_map_tmp_fin as
    (select * from dmd_map_tmp_2 where rnk = 1) 
     ;
     delete from concept_relationship_stage a where relationship_id = 'Maps to'
    and vocabulary_id_1 = 'dm+d' and vocabulary_id_2='dm+d'
    ;
    insert into concept_relationship_stage (CONCEPT_CODE_1,CONCEPT_CODE_2,VOCABULARY_ID_1,VOCABULARY_ID_2,RELATIONSHIP_ID,VALID_START_DATE,VALID_END_DATE)
    select concept_code_1, concept_code_2, 'dm+d', 'dm+d', 'Maps to', to_date('2099-06-22', 'yyyy-mm-dd'), to_date('2099-12-31', 'yyyy-mm-dd') from dmd_map_tmp_fin
    /*
    select * from dmd_map_tmp_fin;
    --
    select * from concept_relationship_stage a
    join concept_relationship_stage b on a.concept_code_2 = b.concept_code_1 and a.relationship_id =b.relationship_id and b.concept_code_2 = a.concept_code_1
    ;
    select * from concept_relationship_stage where vocabulary_id_1 is null
    ;
    select * from concept_relationship_stage where rownum =1
    ;
    SELECT * FROM concept_relationship_stage A JOIN (
    select concept_code_1, CONCEPT_CODE_2 FROM concept_relationship_stage GROUP BY concept_code_1, CONCEPT_CODE_2 HAVING COUNT (1) >1) B ON A.CONCEPT_CODE_1 = B.CONCEPT_CODE_1
    AND A.CONCEPT_CODE_2 = B.CONCEPT_CODE_2
    ;
    SELECT * FROM concept_relationship_stage WHERE CONCEPT_CODE_1 = CONCEPT_CODE_2
    ;
    select * from  concept_relationship_stage a join concept_Stage b on a.concept_code_2 = b.concept_code and b.invalid_reason is not null
    and relationship_id = 'Maps to*/
    ;
    delete from concept_relationship_stage a
    where exists (select 1 from concept_Stage b 
    where 
     a.concept_code_2 = b.concept_code and b.invalid_reason is not null )
     ;
     delete from concept_relationship_stage where concept_code_2 =' '
     ;
     
     --+++ RxE
     drop table concept_stage_no_RxE;
   create table concept_stage_no_RxE as (select * from concept_stage)
   ;
     drop table concept_rel_stage_no_RxE;
   create table concept_rel_stage_no_RxE as (select * from concept_relationship_stage)
   ;
commit;

--select * from drug_strength_stage where drug_concept_code='OMOP274793';
--reverse
drop table concept_relationship_stage 
;
create table concept_relationship_stage as select * from concept_rel_stage_no_RxE
;
drop table concept_stage
;
create table concept_stage as select distinct * from concept_stage_no_RxE
;
select * from concept_stage b left join drug_strength_stage a on a.drug_concept_code = b.concept_code
where a.drug_concept_code is null
and b.concept_class_id ='Clinical Drug Form' and b.invalid_reason is null and b.domain_id ='Drug'
;
--all problem is in RxE defenition
